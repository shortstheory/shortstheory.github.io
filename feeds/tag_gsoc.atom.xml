<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>~Weblog~ - GSoC</title><link href="http://arnavdhamija.com/" rel="alternate"></link><link href="http://arnavdhamija.com/feeds/tag_gsoc.atom.xml" rel="self"></link><id>http://arnavdhamija.com/</id><updated>2018-07-22T22:30:00+05:30</updated><entry><title>GSoC 2018 - Batteries Included!</title><link href="http://arnavdhamija.com/blog/ardupilot-gsoc-update.html" rel="alternate"></link><published>2018-07-22T22:30:00+05:30</published><updated>2018-07-22T22:30:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2018-07-22:/blog/ardupilot-gsoc-update.html</id><summary type="html">&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/qcopter-stock.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Much time has passed and much code has been written since my last update. Adaptive Streaming (a better name TBD) for Ardupilot is nearly complete and brings a whole slew of features useful for streaming video from cameras on robots to laptops, phones, and tablets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic quality selection based on …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/qcopter-stock.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Much time has passed and much code has been written since my last update. Adaptive Streaming (a better name TBD) for Ardupilot is nearly complete and brings a whole slew of features useful for streaming video from cameras on robots to laptops, phones, and tablets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic quality selection based on bandwidth and packet loss estimates&lt;/li&gt;
&lt;li&gt;Options to record the live-streamed video feed to the companion computer (experimental!)&lt;/li&gt;
&lt;li&gt;Fine tuned control over resolution and framerates&lt;/li&gt;
&lt;li&gt;Multiple camera support over RTSP&lt;/li&gt;
&lt;li&gt;Hardware-accelerated H.264 encoding for supported cameras and GPUs&lt;/li&gt;
&lt;li&gt;Camera settings configurable through the APWeb GUI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Phew!&lt;/p&gt;
&lt;p&gt;The configuration required to get everything working is minimal once the required dependencies have been installed. This is in no small part possible thanks to the GStreamer API which took care of several low level complexities of live streaming video over the air.&lt;/p&gt;
&lt;p&gt;Streaming video from aerial robots is probably the most difficult use case of Adaptive Streaming as the WiFi link is very flaky at these high speeds and distances. I've optimised the project around my testing with video streaming from quadcopters so the benefits are passed on to streaming from other robots as well.&lt;/p&gt;
&lt;h2&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;I've used a simplification of TCP's &lt;a href="https://en.wikipedia.org/wiki/TCP_congestion_control"&gt;congestion control&lt;/a&gt; algorithm for Adaptive Streaming. I had looked at other interesting approaches including estimating receiver &lt;a href="https://www.researchgate.net/publication/280738389_An_Analysis_of_TCP-Tolerant_Real-Time_Multimedia_Distribution_in_Heterogeneous_Networks?_sg=pcxT2q90osdkY06gupLQqwssRN0DZrsL3zP2oyqKVIjTML5RhEIWWX5S3-N4KbDRVqHbTc3i2VNzBBpVuQ72t9iSWyT10_8i6w"&gt;buffer occupancy&lt;/a&gt;, but using this approach didn't yield significantly better results. TCP's congestion control algorithm avoids packet loss by mandating ACKs for each successfully delivered packet and steadily increasing sender bandwidth till it reaches a dynamically threshold.&lt;/p&gt;
&lt;p&gt;A crucial difference for Adaptive Streaming is that 1) we stream over UDP for lower overhead (so no automatic TCP ACKs here!) 2) H.264 live video streaming is fairly loss tolerant so it's okay to lose some packets instead of re-transmitting them. &lt;/p&gt;
&lt;p&gt;Video packets are streamed over dedicated RTP packets and Quality of Service (QoS) reports are sent over RTCP packets. These QoS reports give us all sorts of useful information, but we're mostly interested in seeing the number of packets loss between RTCP transmissions.&lt;/p&gt;
&lt;p&gt;On receiving a RTCP packet indicating any packet loss, we immediately shift to a Congested State (better name pending) which significantly reduces the rate at which video streaming bandwidth is increased on receiving a lossless RTCP packet. The encoding H.264 encoding bitrate is limited to no higher than 1000kbps in this state. &lt;/p&gt;
&lt;p&gt;Once we've received five lossless RTCP packets, we shift to a Steady State which can encode upto 6000kbps. In this state we also increase the encoding bitrate at a faster rate than we do in the Congested State. A nifty part of dynamically changing H.264 bitrates is that we can also seamlessly switch the streamed resolution according to the available bandwidth, just like YouTube does with DASH!&lt;/p&gt;
&lt;p&gt;This algorithm is fairly simple and wasn't too difficult to implement once I had figured out all the GStreamer plumbing for extracting packets from buffers. With more testing, I would like to add long-term bitrate adaptations for the bitrate selection algorithm.&lt;/p&gt;
&lt;h2&gt;H.264 Encoding&lt;/h2&gt;
&lt;p&gt;This is where we get into the complicated and wonderful world of video compression algorithms.&lt;/p&gt;
&lt;p&gt;Compression algorithms are used in all kinds of media, such as JPEG for still images and MP3 for audio. H.264 is one of several compression algorithms available for video. H.264 takes advantage of the fact that a lot of the information in video between frames is redundant. so instead of saving 30 frames for 1 second of 30fps video, it saves one entire frame (known as the Key Frame or I-Frame) of video and computes and stores only the differences in frames with respect to the keyframe for the subsequent 29 frames. H.264 also applies some logic to &lt;em&gt;predict&lt;/em&gt; future frames to further reduce the file size. &lt;/p&gt;
&lt;p&gt;This is by no means close to a complete explanation of how H.264 works, for further reading I suggest checking out Sid Bala's &lt;a href="https://sidbala.com/h-264-is-magic/"&gt;explanation&lt;/a&gt; on the topic.&lt;/p&gt;
&lt;p&gt;The legendary Tom Scott also has a fun &lt;a href="https://www.youtube.com/watch?v=r6Rp-uo6HmI"&gt;video explaining how H.264 is adversely affected by snow and confetti&lt;/a&gt;!&lt;/p&gt;
&lt;div class="youtube youtube-16x9"&gt;
&lt;iframe src="https://www.youtube.com/embed/r6Rp-uo6HmI" allowfullscreen seamless frameBorder="0"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The frequency of capturing keyframes can be set by changing the encoder parameters. In the context of live video streaming over unstable links such as WiFi, this is very important as packet loss can cause keyframes to be dropped. Dropped keyframes severely impact the quality of the video until a new keyframe is received. This is because all the frames transmitted after the keyframe only store the differences with respect to the keyframe and do not actually store a full picture on their own.&lt;/p&gt;
&lt;p&gt;Increasing the keyframe interval means we send a large, full frame less frequently, but also means we would suffer from terrible video quality for an extended period of time on losing a keyframe. On the other hand, shorter keyframe intervals can lead to a wastage of bandwidth.&lt;/p&gt;
&lt;p&gt;I found that a keyframe interval of every 10 frames worked much better than the default interval of 60 frames without impacting bandwidth usage too significantly.&lt;/p&gt;
&lt;p&gt;Lastly, H.264 video encoding is a very computationally expensive algorithm. Software-based implementations of H.264 such as &lt;code&gt;x264enc&lt;/code&gt; are well supported with several configurable parameters but have prohibitively high CPU requirements, making it all but impossible to livestream H.264 encoded video from low power embedded systems. Fortunately, the Raspberry Pi's Broadcom BCM2837 SoC has a dedicated H.264 hardware encoder pipeline for the Raspberry Pi camera which drastically reduces the CPU load in high definition H.264 encoding. Some webcams such as the Logitech C920 and higher have onboard H.264 hardware encoding thanks to special ASIC's dedicated for this purpose.&lt;/p&gt;
&lt;p&gt;Adaptive Streaming probes for the type of encoding supported by the webcam and whether it has the IOCTL's required for changing the encoding parameters on-the-fly.&lt;/p&gt;
&lt;p&gt;H.264 has been superseded by the more efficient H.265 encoding algorithm, but the CPU requirements for H.265 are even higher and it doesn't enjoy the same hardware support as H.264 does for the time being.&lt;/p&gt;
&lt;h2&gt;GUI&lt;/h2&gt;
&lt;p&gt;The project is soon-to-be integrated with the APWeb project for configuring companion computers. Adaptive Streaming works by creating an RTSP Streaming server running as a daemon process. The APWeb process connects to this daemon service over a local socket to populate the list of cameras, RTSP mount points, and available resolutions of each camera.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/apweb-screenshot.png"&gt;&lt;/p&gt;
&lt;p&gt;The GUI is open for improvement and I would love feedback on how to make it easier to use!&lt;/p&gt;
&lt;p&gt;Once the RTSP mount points are generated, one can livestream the video feed by entering in the RTSP URL of the camera into VLC. This works on all devices supporting VLC. However, VLC does add two seconds of latency to the livestream for reducing the jitter. I wasn't able to find a way to configure this in VLC, so an alternative way to get a lower latency stream is by using the following &lt;code&gt;gst-launch&lt;/code&gt; command in a terminal:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gst-launch-1.0 playbin uri=&amp;lt;RTSP Mount Point&amp;gt; latency=100&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In the scope of the GSoC timeline, I'm looking to wind down the project by working on documentation, testing, and reducing the cruft from the codebase. I'm looking forward to integrating this with companion repository soon!&lt;/p&gt;
&lt;p&gt;Links to the code:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/shortstheory/adaptive-streaming"&gt;https://github.com/shortstheory/adaptive-streaming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/shortstheory/APWeb"&gt;https://github.com/shortstheory/APWeb&lt;/a&gt;&lt;/p&gt;</content><category term="Ardupilot"></category><category term="GSoC"></category><category term="Programming"></category></entry><entry><title>GSoC 2018 - New Beginnings</title><link href="http://arnavdhamija.com/blog/ardupilot-gsoc-intro.html" rel="alternate"></link><published>2018-06-05T18:30:00+05:30</published><updated>2018-06-05T18:30:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2018-06-05:/blog/ardupilot-gsoc-intro.html</id><summary type="html">&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/ardupilot_logo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;I'm really excited to say that I'll be working with &lt;a href="ardupilot.org"&gt;Ardupilot&lt;/a&gt; for the better part of the next two months! Although this is the second time I'm making a foray into Open Source Development, the project at hand this time is quite different from what I had worked on in …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/ardupilot_logo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;I'm really excited to say that I'll be working with &lt;a href="ardupilot.org"&gt;Ardupilot&lt;/a&gt; for the better part of the next two months! Although this is the second time I'm making a foray into Open Source Development, the project at hand this time is quite different from what I had worked on in my first GSoC project.&lt;/p&gt;
&lt;p&gt;Ardupilot is an open-source autopilot software for several types of semi-autonomous robotic vehicles including multicopters, fixed-wing aircraft, and even marine vehicles such as boats and submarines. As the name suggests, Ardupilot was formerly based on the Arduino platform with the APM2.x flight controllers which boasted an ATMega2560 processor. Since then, Ardupilot has moved on to officially supporting much more advanced boards with significantly better processors and more robust hardware stacks. That said, these flight controllers contain application specific embedded hardware which is unsuitable for performing intensive tasks such as real-time object detection or video processing.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/apsync-configurator.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CC Setup with a Flight Computer&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ardupilot.org/dev/docs/apsync-intro.html"&gt;APSync&lt;/a&gt; is a recent Ardupilot project which aims to ameliorate the limited processing capability of the flight controllers by augmenting them with so-called companion computers (CCs). As of writing, APSync officially supports the Raspberry Pi 3B(+) and the NVidia Jetson line of embedded systems. One of the more popular use cases for APSync is to enable out-of-the-box live video streaming from a vehicle to a laptop. This works by using the CC's onboard WiFi chip as a WiFi hotspot to stream the video using GStreamer. However, the current implementation has some shortcomings which are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only one video output can be unicasted from the vehicle&lt;/li&gt;
&lt;li&gt;The livestreamed video progressively deteriorates as the WiFi link between the laptop and the CC becomes weaker&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is where my GSoC project comes in. My project is to tackle the above issues to provide a good streaming experience from an Ardupilot vehicle. The former problem entails rewriting the video streaming code to allow for sending multiple video streams at the same time. The latter is quite a bit more interesting and it deals with several computer networks and hardware related engineering issues to solve. "Solve" is a subjective term here as there isn't any way to significantly boost the WiFi range from the CC's WiFi hotspot without some messy hardware modifications.&lt;/p&gt;
&lt;p&gt;What can be done is to degrade the video quality as gracefully as possible. It's much better to have a smooth video stream of low quality than to have a high quality video stream laden with jitter and latency. At the same time, targeting to only stream low quality video when the WiFi link and the processor of the CC allows for better quality is inefficient. To "solve" this, we would need some kind of dynamically adaptive streaming mechanism which can change the quality of the video streamed according to the strength of the WiFi connection.&lt;/p&gt;
&lt;p&gt;My first thought was to use something along the lines of Youtube's &lt;a href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP"&gt;DASH&lt;/a&gt; (Dynamically Adaptive Streaming over HTTP) protocol which automatically scales the video quality according to the available bandwidth. However, DASH works in a fundamentally different way from what is required for adaptive livestreaming. DASH relies on having the same video pre-encoded in several different resolutions and bitrates. The server estimates the bandwidth of its connection to the client. On doing so, the server chooses one of the pre-encoded video chunks to send to the client. Typically, the server tries to guess which video chunk can deliver the best possible quality without buffering.&lt;/p&gt;
&lt;p&gt;Youtube's powerful servers have no trouble encoding a video several times, but this approach is far too intensive to be carried out on a rather anemic Raspberry Pi. Furthermore, DASH relies on QoS (short for Quality of Service which includes parameters like bitrate, jitter, packet loss, etc) reports using TCP ACK messages. This causes more issues as we need to stream the video down using RTP over UDP instead of TCP. The main draw of UDP for livestreaming is that performs  better than TCP does on low bandwidth connections due to its smaller overhead. Unlike TCP which places guarantees on message delivery through ACKs, UDP is purely best effort and has no concept of ACKs at the transport layer. This means we would need some kind of ACK mechanism at the application layer to measure the QoS.&lt;/p&gt;
&lt;p&gt;Enter &lt;a href="https://tools.ietf.org/html/rfc3550"&gt;RTCP&lt;/a&gt;. This is the official sibling protocol to RTP which among other things, reports packet loss, cumulative sequence number received, and jitter. In other words - it's everything but the kitchen sink for QoS reports for multimedia over UDP! What's more, GStreamer natively integrates RTCP report handling. This is the approach I'll be using for getting estimated bandwidth reports from each receiver.&lt;/p&gt;
&lt;p&gt;I'll be sharing my experiences with the H.264 video encoders and hardware in my next post.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Other links&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) My GSoC Proposal for &lt;a href="https://docs.google.com/document/d/17iZgdBqVHGa-ny3XQ73sAKmYxeUcWsS3eeeKzBS8F4s/edit?usp=sharing"&gt;Ardupilot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2) Previous &lt;a href="http://arnavdhamija.com/blog/tag/gsoc.html"&gt;GSoC Posts&lt;/a&gt;&lt;/p&gt;</content><category term="Ardupilot"></category><category term="GSoC"></category><category term="Programming"></category></entry><entry><title>GSoC Report - Wrapping up GSoC 2016</title><link href="http://arnavdhamija.com/blog/gsoc-report-wrapping-up-gsoc-2016.html" rel="alternate"></link><published>2016-08-30T01:45:00+05:30</published><updated>2016-08-30T01:45:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2016-08-30:/blog/gsoc-report-wrapping-up-gsoc-2016.html</id><summary type="html">&lt;p&gt;That’s it. After a &lt;a href="https://github.com/KDE/kio-stash/graphs/contributors"&gt;combined total&lt;/a&gt; of 217 git commits, 6,202 lines of code added, and
4,167 lines of code deleted, GSoC 2016 is finally over.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/Screenshot_20160830_014801.png"&gt;&lt;/p&gt;
&lt;p&gt;These twelve weeks of programming have been a very enriching experience for me
and making this project has taught me a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;That’s it. After a &lt;a href="https://github.com/KDE/kio-stash/graphs/contributors"&gt;combined total&lt;/a&gt; of 217 git commits, 6,202 lines of code added, and
4,167 lines of code deleted, GSoC 2016 is finally over.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/Screenshot_20160830_014801.png"&gt;&lt;/p&gt;
&lt;p&gt;These twelve weeks of programming have been a very enriching experience for me
and making this project has taught me a lot about production quality software
development. Little did I know that a &lt;a href="https://github.com/shortstheory/filetray-very-early-alpha-idea-
thingy"&gt;small
project&lt;/a&gt; I had put together in a 6 hour session of messing around with Qt would
lead to something as big as this!  &lt;/p&gt;
&lt;p&gt;There have been many memorable moments throughout my coding period for the
GSoC - such as the first time I got an ioslave to
&lt;a href="http://arnavdhamija.com/blog/gsoc-update-1-beginning.html"&gt;install&lt;/a&gt; correctly, to writing its “Hello World”
&lt;a href="{filename}/2016-06-21-gsoc-update-writing-kio-slave-101.md"&gt;equivalent&lt;/a&gt;, and getting a basic implementation of the project up and
running by doing a series of dirty hacks with Dolphin’s code. There were also
times when I was so frustrated with debugging for this project, that I wanted
to do nothing but smash my laptop’s progressively failing display panel with
the largest hammer I could find. The great mentorship from my GSoC mentor and
the premise of the GSoC program itself kept me going. This also taught me an
important lesson with regards to software development - no one starting out
gets it right on their first try. It feels like after a long run of not quite
getting the results I wanted, the GSoC is the thing which worked out for me as
everything just fell into place.  &lt;/p&gt;
&lt;p&gt;There’s a technical digression here, which you can feel free to skip through
if you don’t want to get into the details of the project.  &lt;/p&gt;
&lt;p&gt;Following up from the &lt;a href="http://arnavdhamija.com/blog/gsoc-update-tinkering-with-kio.html"&gt;previous&lt;/a&gt; blog post, with the core features of the
application complete, I had moved on to unit testing my project. For this
project, unit testing involved writing test cases for each and every component
of the application to find and fix any bugs. Despite the innocuous name, unit
testing this project was a much bigger challenge than I expected. As for one
thing, the ioslave in my project is merely a controller in the MVC system of
the virtual Stash File System, the Dolphin file manager, and the KIO Slave
itself. Besides, most of the ioslave’s functions have a void return type, so
feeding the slave’s functions’ arguments to get an output for checking was not
an option either.  &lt;/p&gt;
&lt;p&gt;This led me to use an approach, which my mentor aptly called “black box
testing”.  &lt;/p&gt;
&lt;p&gt;In this approach, one writes unit tests testing for a specific action and then
checking for whether the effects of the said action are as expected. In this
case, the ioslave was tested by giving it a test file and then apply some of
the ioslave’s functions such as copy, rename, delete, and stat. From there,
through a bunch of QVERIFY calls is to check whether the ioslave has completed
the operation successfully. Needless to say, this approach is far more
convoluted to write unit tests for as it required checking each and every test
file for its properties in every test case. Fortunately, the
&lt;a href="http://doc.qt.io/qt-4.8/qtestlib-manual.html#qtestlib"&gt;QTestLib&lt;/a&gt; API is
pretty well documented so it wasn’t difficult to get started with writing unit
tests. I also had a template of what a good test suite should look like thanks
to David Faure’s excellent work on implementing automated unit testing for the
Trash ioslave. With these two tools in hand, I started off with writing unit
tests shortly before the second year of college started.  &lt;/p&gt;
&lt;p&gt;As expected, writing black box unit tests was a PITA in its own right. The
first time I ran my unit test I came up with a dismal score of 6 unit tests
passed out of the 17 I had written. This lead me to go back and check whether
my unit tests were testing correctly at all. It turned out that I had made so
many mistakes with writing the unit tests that an entire rewrite of the test
suite wasn’t unwarranted.  &lt;/p&gt;
&lt;p&gt;With a rewrite of the test cases completed, I ran the test suite again. The
results were a bit better - 13 out of the 17 test cases passed, but 4 failed
test cases - enough reason for the project to be unshippable. Looking into the
issue a bit deeper, I found out that all the D-Bus calls to my ioslave for
copy and move operations were not working correctly! Given that I had spent so
much time on making sure the ioslave was robust enough, this was a mixed
surprise. Finally, after a week of rewriting and to an extent, refactoring the
rename and copy functions of the ioslave, I got the best terminal output I
ever wanted from this project.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/Screenshot_20160829_184812.png"&gt;&lt;/p&gt;
&lt;p&gt;Definitely the highest point of the GSoC for me. From there on out, it was a
matter of putting the code on the slow burner for cleaning up any leftover
debug statements and for writing documentation for other obscure sections.
With a net total of nearly 2000 lines of code, it far surpasses any other
project I’ve done in terms of size and quality of code written.  &lt;/p&gt;
&lt;p&gt;At some points in the project, I felt that the stipend was far too generous,
for many people working on KDE &lt;em&gt;voluntarily&lt;/em&gt; produce projects much larger
thann mine. In the end, I feel the best way to repay the generosity is to
continue with open source development - just as the GSoC intended. Prior to
the GSoC, open source was simply an interesting concept to me, but
contributing a couple of thousands of lines of code to an open source codebase
has made me realise just how powerful open source is. There were no
restrictions on when I had to work (usually my productivity was at its peak at
outlandish late night hours), on the machine I used for coding (a trusty
IdeaPad, replaced with a much nicer ThinkPad), or on the place where I felt
most comfortable coding from (a toss up between my much used study table or
the living room). In many ways, working from home was probably the &lt;em&gt;best&lt;/em&gt;
environment I could ask for when it came to working on this project. Hacking
on an open source project gave me a sense of gratification solving a problem
in competitive programming never could have.  &lt;/p&gt;
&lt;p&gt;The Google Summer of Code may be over, but my journey with open source
development has just begun. Here’s to even bigger and better projects in the
future!&lt;/p&gt;</content><category term="GSoC"></category><category term="KDE"></category></entry><entry><title>GSoC Update: Tinkering with KIO</title><link href="http://arnavdhamija.com/blog/gsoc-update-tinkering-with-kio.html" rel="alternate"></link><published>2016-07-21T15:18:00+05:30</published><updated>2016-07-21T15:18:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2016-07-21:/blog/gsoc-update-tinkering-with-kio.html</id><summary type="html">&lt;p&gt;I'm a lot closer to finishing the project now. Thanks to some great support
from my GSoC mentor, my project has turned out better than what I had written
about in my proposal! Working together, we've made a lot of changes to the
project.  &lt;/p&gt;
&lt;p&gt;For starters, we've changed the name …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm a lot closer to finishing the project now. Thanks to some great support
from my GSoC mentor, my project has turned out better than what I had written
about in my proposal! Working together, we've made a lot of changes to the
project.  &lt;/p&gt;
&lt;p&gt;For starters, we've changed the name of the ioslave from "File Tray" to
"staging" to "stash". I wasn't a big fan of the name change, but I see the
utility in shaving off a couple of characters in the name of what I hope will
be a widely used feature.  &lt;/p&gt;
&lt;p&gt;Secondly, the ioslave is now completely independent from Dolphin, or any KIO
application for that matter. This means it works &lt;em&gt;exactly&lt;/em&gt; the same way across
the entire suite of KIO apps. Given that at one point we were planning to make
the ioslave fully functional only with Dolphin, this is a major plus point for
the project.  &lt;/p&gt;
&lt;p&gt;Next, the backend for storing stashed files and folders has undergone a
complete overhaul. The first iteration of the project stored files and folders
by saving the URLs of stashed items in a QList in a custom "stash" daemon
running on top of kded5. Although this was a neat little solution which worked
well for most intents and purposes, it had some disadvantages. For one, you
couldn't delete and move files around on the ioslave without affecting the
source because they were all linked to their original directories. Moreover,
with the way 'mkdir' works in KIO, this solution would never work without each
application being specially configured to use the ioslave which would entail a
lot of groundwork laying out QDBus calls to the stash daemon. With these
problems looming large, somewhere around the midterm evaluation week, I got a
message from my mentor about ramping up the project using a "StashFileSystem",
a virtual file system in Qt that he had written just for this project.  &lt;/p&gt;
&lt;p&gt;The virtual file system is a clever way to approach this - as it solved both
of the problems with the previous approach right off the bat - mkdir could be
mapped to virtual directory and now making volatile edits to folders is
possible without touching the source directory. It did have its drawbacks too - as it needed to stage every file in the source directory, it would require a
lot more memory than the previous approach. Plus, it would still be at the
whims of kded5 if a contained process went bad and crashed the daemon.  &lt;/p&gt;
&lt;p&gt;Nevertheless, the benefits in this case far outweighed the potential cons and
I got to implementing it in my ioslave and stash daemon. Using this virtual
file system also meant remapping all the SlaveBase functions to corresponding
calls to the stash daemon which was a complete rewrite of my code. For
instance, my GitHub log for the week of implementing the virtual file system
showed a sombre 449++/419--. This isn't to say it wasn't productive though -
to my surprise the virtual file system actually worked better than I hoped it
would! Memory utilisation is low at a nominal ~300 bytes per stashed file and
the performance in my manual testing has been looking pretty good.  &lt;/p&gt;
&lt;p&gt;With the ioslave and other modules of the application largely completed, the
current phase of the project involves integrating the feature neatly with
Dolphin and for writing a couple of unit tests along the way. I'm looking
forward to a good finish with this project.  &lt;/p&gt;
&lt;p&gt;You can find the source for it here: &lt;a href="https://github.com/KDE/kio-stash"&gt;https://github.com/KDE/kio-stash&lt;/a&gt; (did I
mention it's now hosted on a &lt;a href="https://quickgit.kde.org/?p=kio-
stash.git"&gt;KDE repo&lt;/a&gt;? ;) )&lt;/p&gt;</content><category term="GSoC"></category><category term="KDE"></category></entry><entry><title>GSoC Update 1: The Beginning</title><link href="http://arnavdhamija.com/blog/gsoc-update-1-beginning.html" rel="alternate"></link><published>2016-05-30T10:37:00+05:30</published><updated>2016-05-30T10:37:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2016-05-30:/blog/gsoc-update-1-beginning.html</id><summary type="html">&lt;p&gt;I have officially started my &lt;a href="https://summerofcode.withgoogle.com/projects/#5979393230897152"&gt;GSoC
project&lt;/a&gt; under
the mentorship of &lt;a href="https://blog.baloneygeek.com/"&gt;Boudhayan Gupta &lt;/a&gt;and &lt;a href="http://blog.pinak.me/"&gt;Pinak
Ahuja&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;The project idea's implementation has undergone some changes from what I
proposed. While the essence of the project is the same, it will now no longer
be dependent on Baloo and xattr. Instead, it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have officially started my &lt;a href="https://summerofcode.withgoogle.com/projects/#5979393230897152"&gt;GSoC
project&lt;/a&gt; under
the mentorship of &lt;a href="https://blog.baloneygeek.com/"&gt;Boudhayan Gupta &lt;/a&gt;and &lt;a href="http://blog.pinak.me/"&gt;Pinak
Ahuja&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;The project idea's implementation has undergone some changes from what I
proposed. While the essence of the project is the same, it will now no longer
be dependent on Baloo and xattr. Instead, it will use a QList to hold a list
of staged files with a plugin to kiod. My next milestone before the mid-term
evaluation is to implement this in a KIO slave which will be compatible with
the whole suite of KDE applications.  &lt;/p&gt;
&lt;p&gt;For the last two weeks, I've been busy with going through hundreds of lines of
source code to understand the concept of a KIO slave. The KIO API is a very
neat feature of KDE - it provides a single, consistent way to access remote
and local filesystems. This is further expanded to KIO slaves which are
programs based on the KIO API which allow for a filesystem to be expressed in
a particular way. For instance, there is a KIO slave for displaying xattr file
&lt;a href="http://vhanda.in/blog/2014/07/tagging-your-files/"&gt;tags&lt;/a&gt; as a directory under
which each file marked to a tag would be displayed. KIO slaves even expand to
network protocols allowing for remote access using slaves such as http:/,
ftp:/, smb:/ (for Windows samba shares), fish:/, sftp:/, nfs:/, and webdav:/.
My project requires virtual folder constructed of URLs stored in a QList - an
ideal fit for KIO slaves.  &lt;/p&gt;
&lt;p&gt;However, hacking on KIO slaves was not exactly straightforward. Prior to my
GSoC selection, I had no idea on how to edit CMakeLists.txt files and it was a
task to learn to make one by hand. Initially, it felt like installing the
dependencies for building KIO slaves would almost certainly lead to me
destroying my KDE installation, and sure enough, I did manage to ruin my
installation. Most annoying. Fortunately, I managed to recover my data and
with a fresh install of Kubuntu 16.04 with all the required KDE packages, I
got back to working on getting the technical equivalent of a Hello World to
work with a KIO slave.  &lt;/p&gt;
&lt;p&gt;This too, was more than a matter of just copying and pasting lines of code
from the &lt;a href="https://techbase.kde.org/Development/Tutorials/KIO_Sla
ves/Hello_World"&gt;KDE tutorial&lt;/a&gt;. KIO slaves had dropped the use of .protocol files in the KF5
transition, instead opting for JSON files to store the properties of the KIO
slave. Thankfully, I had the assistance of the legendary &lt;a href="https://behindkde.org/david-faure-2"&gt;David
Faure&lt;/a&gt;. Under his guidance, I managed to
port the KIO slave in the tutorial to a KF5 compatible KIO slave and after a
full week of frustration of dealing with dependency hell, I saw the best Hello
World I could ever hope for:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/kioslave.png"&gt;&lt;/p&gt;
&lt;p&gt;Baby steps. The next step was to make the KIO slave capable of displaying the
contents of a specified QUrl in a file manager. The documentation for
KProtocolManager made it seem like a pretty straightforward task - apparently
that all I needed to do was to add a "listing" entry in my JSON protocol file
and I would have to re-implement the listDir method inherited from SlaveBase
using a call to SlaveBase::listDir(&amp;amp;QUrl). Unbeknownst to me, the SlaveBase
class actually didn't have any code for displaying a directory! The SlaveBase
class was only for reimplementing its member functions in a derived class as I
found out by going through the source code of the core of kio/core. Learning
from my mistake here I switched to using a ForwardingSlaveBase class for my
KIO slave which instantly solved my problems of displaying a directory.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/helloslave.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fistpump&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;According to my timeline, the next steps in the project are  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Finishing off the KIO slave by the end of this month&lt;/li&gt;
&lt;li&gt;Making GUI modifications in Dolphin to accommodate the staging area&lt;/li&gt;
&lt;li&gt;Thinking of a better name for this feature?
So far, it's been a great experience to get so much support from the KDE
community. Here's to another two and a half months of KDE development!&lt;/li&gt;
&lt;/ol&gt;</content><category term="GSoC"></category><category term="Programming"></category><category term="KDE"></category></entry><entry><title>It has happened - GSoC 2016 Selection!</title><link href="http://arnavdhamija.com/blog/it-has-happened.html" rel="alternate"></link><published>2016-04-23T12:28:00+05:30</published><updated>2016-04-23T12:28:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2016-04-23:/blog/it-has-happened.html</id><summary type="html">&lt;p&gt;Wow!  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/photo_2016-04-23_12-26-30.jpg"&gt;&lt;/p&gt;
&lt;p&gt;I have been selected for the Google Summer of Code!  &lt;/p&gt;
&lt;p&gt;For the better part of the summer vacation, I will now be committing myself to
write code for &lt;a href="https://www.kde.org/"&gt;KDE&lt;/a&gt; to implement my project idea of
implementing a &lt;a href="https://goo.gl/BYOWdG"&gt;virtual folder in Dolphin&lt;/a&gt; to make it
easier to select files.  &lt;/p&gt;
&lt;p&gt;As …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Wow!  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://arnavdhamija.com/images/photo_2016-04-23_12-26-30.jpg"&gt;&lt;/p&gt;
&lt;p&gt;I have been selected for the Google Summer of Code!  &lt;/p&gt;
&lt;p&gt;For the better part of the summer vacation, I will now be committing myself to
write code for &lt;a href="https://www.kde.org/"&gt;KDE&lt;/a&gt; to implement my project idea of
implementing a &lt;a href="https://goo.gl/BYOWdG"&gt;virtual folder in Dolphin&lt;/a&gt; to make it
easier to select files.  &lt;/p&gt;
&lt;p&gt;As a primer, the &lt;a href="http://g.co/gsoc"&gt;Google Summer of Code &lt;/a&gt;(GSoC) is an annual
event organized by Google for drawing students to work on open source projects
with a nice stipend, goodies, and fame. The GSoC is a term one would hear
pretty frequently when talking about the technical prowess and coding culture
of a college.  &lt;/p&gt;
&lt;p&gt;This year, BITS Pilani - Hyderabad Campus had a record number of a total of
&lt;strong&gt;7&lt;/strong&gt; selections! This is more than double of our previous record. This in
some ways, might be the start of the technical culture wave this campus was
looking for so long.  &lt;/p&gt;
&lt;p&gt;The File Tray idea for the GSoC came at a difficult time, hardly a month after
the entrance exams in 2015. It was at a time I was frustrated with everything
I had done and I didn't have any energy to pursue anything at all having been
completely drained out by the entrance exams prior to it. From there, the
project sat on the list of "Things I Might Do In The Distant Future". The
project idea was known only to a few close friends and my tiny programming
diary.  &lt;/p&gt;
&lt;p&gt;It was only till November 2015 when I stumbled across the GSoC. I began
looking at open source file managers for which I could implement my project
idea. I had been using Linux with various desktop environments for about 4
years at that point, so I had a pretty decent idea of what to look for.
Writing this feature for GNOME's Nautilus was the first thing I looked into as
I had been using Nautilus for a while and I was a big fan of Nautilus's simple
to use interface. But, the problem was that Nautilus was a C/GTK+ project and
I had no desire to move on to using C after having C++ in my comfort zone for
a very long time. Fortunately, Dolphin, one of the best file managers I had
used since my days of using KDE, used C++/Qt, a toolset I am much better with.
I felt my project idea was a natural fit for Dolphin's Split view mode. KDE
also had an excellent record in the GSoC with a very good number of slots and
a high percentage of successful projects. This began my tryst with Open Source
development.  &lt;/p&gt;
&lt;p&gt;From there on, I taught myself &lt;a href="http://www.qt.io/"&gt;Qt&lt;/a&gt; and during a Diwali
vacation on campus, I managed to make a very rough &lt;a href="https://github.com/shortstheory/filetray-very-early-alpha-idea-
thingy"&gt;prototype
application&lt;/a&gt; of my project after coding for 6 hours straight from 11pm to 5am the
next day. Following this, I subscribed to KDE's mailing lists and after
lurking around for a while, I started asking for feedback on my GSoC idea.
With surprisingly positive feedback from numerous KDE developers, I realized
that there might just be a non-zero chance of getting selected.  &lt;/p&gt;
&lt;p&gt;Things quickly began falling into place and I then moved on to the next step
of hunting around for bugs I could fix and new features I could implement for
Dolphin. The bug-fixing was as enjoyable as it was occasionally frustrating.
Reading over 20000 lines of code certainly took its toll when I had no idea
when how different parts of the application meshed together. In the end,
thanks to the guidance of Dolphin maintainer, Emmanuel Pescosta, I managed to
fix a couple of things for Dolphin and moved on to the next step of making a
proposal for my GSoC application.  &lt;/p&gt;
&lt;p&gt;Starting off with making a competent proposal was like launching off ground
zero as there were very few people who had successfully completed the GSoC
from our campus and most of these people had graduated well before this time.
I started digging around for proposals accepted by KDE in previous GSoC's.
What I couldn't get from all the proposals was some sound advice from seniors.
In particular, &lt;a href="https://github.com/naveenjafer"&gt;Naveen Jafer bhaiya&lt;/a&gt; (who also
went on to achieve a GSoC project of his own!) helped me with making my
proposal as good as possible. In the end, after painstakingly checking every
word in my proposal for what felt like the fiftieth time I submitted it on 25
March, only to spend an anxious month waiting for the results which came out
at 1230am IST on April 23. While it still hasn't sunk in yet (!), I am sure
that this will make for an awesome summer vacation!&lt;/p&gt;</content><category term="GSoC"></category><category term="KDE"></category></entry><entry><title>GSoC 2016 Project Survey, help me make Dolphin a better File Manager!</title><link href="http://arnavdhamija.com/blog/gsoc-2016-project-survey-help-me-make.html" rel="alternate"></link><published>2016-02-15T21:16:00+05:30</published><updated>2016-02-15T21:16:00+05:30</updated><author><name>Arnav Dhamija</name></author><id>tag:arnavdhamija.com,2016-02-15:/blog/gsoc-2016-project-survey-help-me-make.html</id><summary type="html">&lt;p&gt;Hey everyone!  &lt;/p&gt;
&lt;p&gt;I am a first year computer science undergraduate from BITS Pilani, Hyderabad
Campus. I am looking forward to working for KDE for the GSoC.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://developers.google.com/open-source/gsoc/resources/downloads/GSoC2016Logo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;My project idea is based on solving a problem all file managers have had for
years - the lack of an easy to use file …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hey everyone!  &lt;/p&gt;
&lt;p&gt;I am a first year computer science undergraduate from BITS Pilani, Hyderabad
Campus. I am looking forward to working for KDE for the GSoC.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://developers.google.com/open-source/gsoc/resources/downloads/GSoC2016Logo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;My project idea is based on solving a problem all file managers have had for
years - the lack of an easy to use file selection tool. My project aims to
simplify selecting files from multiple directory trees.  &lt;/p&gt;
&lt;p&gt;I am running a survey to gauge community feedback on my idea and to finalize
the user interface and features list.  &lt;/p&gt;
&lt;p&gt;The link to my idea proposal can be found here: &lt;a href="https://goo.gl/1Nj4SY"&gt;https://goo.gl/1Nj4SY&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;And the link to my survey can be found here: &lt;a href="https://goo.gl/forms/5JSZXNganX"&gt;https://goo.gl/forms/5JSZXNganX&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;TIA for the feedback : )&lt;/p&gt;</content><category term="GSoC"></category><category term="Programming"></category><category term="KDE"></category></entry></feed>